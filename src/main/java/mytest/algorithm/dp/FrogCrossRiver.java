package mytest.algorithm.dp;

import java.util.Arrays;

/**
 * 题目描述
 * 在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。由于桥的长度和青蛙一次跳过的距离都是正整数，
 * 我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0,1,…,L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，
 * 不停的向终点方向跳跃。一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。
 * <p>
 * 题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。
 * <p>
 * 输入格式
 * 第一行有1个正整数L(1 ≤ L ≤10^9)，表示独木桥的长度。
 * <p>
 * 第二行有3个正整数S,T,M，分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中1≤S≤T≤10,1≤M≤100。
 * <p>
 * 第三行有M个不同的正整数分别表示这M个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。
 * <p>
 * 输出格式
 * 一个整数，表示青蛙过河最少需要踩到的石子数。
 * <p>
 * 输入输出样例
 * 输入 #1
 * <p>
 * 10
 * 2 3 5
 * 2 3 5 6 7
 * 输出 #1
 * <p>
 * 2
 * 说明/提示
 * 对于30%的数据，1≤L≤10000；
 * <p>
 * 对于全部的数据，1≤L≤10^9。
 * ————————————————
 * 版权声明：本文为CSDN博主「漫步星云」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
 * 原文链接：https://blog.csdn.net/weixin_44062302/article/details/104109135
 * https://ac.nowcoder.com/acm/problem/16655
 *
 * @author : feiya
 * @date : 2021/3/14
 * @description :
 */
public class FrogCrossRiver {
    /**
     * 独木桥上青蛙可能到达的点看成数轴上的一串整点：0,1,…,L（其中L是桥的长度）。坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。
     * 一次跳跃的距离是S到T之间的任意正整数（包括S,T）
     * 题解 https://ac.nowcoder.com/acm/problem/blogs/16655
     * https://zhuanlan.zhihu.com/p/142569754
     * @param length    桥的长度
     * @param jumpS     跳跃的最短距离
     * @param jumpT     跳跃的最大距离
     * @param stonesNum 桥上石子的个数
     * @param stones    桥上石子在桥上的位置
     * @return 青蛙过河最少需要踩到的石子数
     */
    public int crossRiver(int length, int jumpS, int jumpT, int stonesNum, int[] stones) {
        // 如果每次跳的距离一样,则跳的位置固定，每次跳的位置为 jumpS、2jumpS、3jumpS 。。。
        // 如果石头的位置恰好是 jumpS 整数倍，那么刚好跳到这个石头上
        if (jumpS == jumpT) {
            int min = 0;
            for (int stone : stones) {
                if (stone % jumpS == 0) {
                    min++;
                }
            }
            return min;
        }

        // 如果每次跳的位置不同，用dp[i] 表示走到 i 位置时，踩的最少的石子数
        // i这个位置没有石头：dp[i]=min(dp[i],dp[k]) 从上一次位置跳到 i 时，由于从 k 跳最小是 dp[k] 次，到 i 要么是dp[k] 要么是dp[k]+1次
        // i这个位置是石头：dp[i]=min(dp[i],dp[k]+1)
        // (k是上一步的位置，S <= i-k <=T) 因为跳的范围是 S -> T
        // 如果以桥长来记录每个位置，由于桥太长，dp数组放不下每个位置
        // 由于 M <= 100, 石头的数目小于等于100,但是从起点到终点一共的举例是10^9.所以路中的很大一段是没有石头的
        // 也就是说总是存在一些石头离得非常远，从前一个石头到这个石头需要跳很多步才能到达，而只要S和T不等，那么在这漫长的跳跃中我们总可以调整步幅
        // 可以到达这个石子，也可以跳过这个石子，换句话说，只要S和T不等当两个石子之间的距离超过了一定范围之后，任意距离都是可以到达的，
        // 这个时候两个离得很远的石头之间的距离就不重要了，假如这个超过的范围是 30，那么石子在 30 或者在 300 或者在 2234 任意位置，都和在30的效果一样

        // 比如 S=5，T=7时:
        // 可以到达的位置为
        // 5、7、10=5+5、12=5+7、15=5+5+5、17=5+5+7、19=5+7+7、20=5+5+5+5、21=7+7+7、
        // 22=5+5+7+5、24=5+5+7+7、25=5+5+5+5+5、26=5+7+7+7、27=5+5+5+5+7、28=7+7+7+7、
        // 29=5+5+5+7+7、30=5+5+5+5+5+5、31=5+5+7+7+7、32=5+5+5+5+5+7、33=5+7+7+7+7、34=5+5+5+5+7+7、
        // 35=5+5+5+5+5+5+5或7+7+7+7+7  之后所有的位置都能通过不同的 s t 组合到达
        // 两个石子距离  35000 其实也等效于在 35 处，也即是可以把大于 35 的位置的石子 等效于 石子在35处
        // 本题 s 和 t最大取值为 9 * 10 = 90， 让任意两个距离大于90的石头距离为90就可以了 ， 100 个石头，10020的数组足够满足最大情况了

        // 对石头位置数组排序，避免传过来的是无序数组
        Arrays.sort(stones, 0, stonesNum + 1);
        // 存放 dp 结果
        int[] f = new int[10020];
        // 存放离散后的石头位置，0表示没石头 1表示有石头
        int[] w = new int[10020];

        int last = 0, k = 0;
        for (int i = 1; i <= stonesNum; i++) {
            // 两个石头之间的位置（如果距离大于100，那么这100个位置设置为0，没有石头）（100是更冗余一点）
            for (int j = 1; j <= Math.min(stones[i] - last, 100); j++) {
                w[++k] = 0;
            }
            // 下一个位置标记为有石头 1
            w[k] = 1;
            last = stones[i];
        }
        // 不用遍历到 L ，只需遍历到最后一个石头位置K后，加 10 是避免落到最后一个石头上
        for (int i = 1; i <= k + 10; i++) {
            f[i] = 110000;
            // 找出能跳到 i 位置之前可能跳的位置 的最小值作为 i位置的能遇到石头的值
            for (int j = jumpS; j <= jumpT; j++) {
                if (i - j >= 0) {
                    f[i] = Math.min(f[i], f[i - j] + w[i]);
                }
            }
        }

        // 找出f[] 中最小的那一个作为结果
        int result = 110000;
        for (int i = k; i <= k + 10; i++) {
            result = Math.min(result, f[i]);
        }

        return result;
    }
}
